if (ml == 2) {
fits.nna <- fits[!sapply(fits, function(x)
all(is.na(x)))]
na <- length(fits) - length(fits.nna)
sh.na <- na / length(fits)
if (!all(index %in% names(fits.nna[[1]][1, ])))
stop("At least one selected index is not a supported fitmeasure in lavaan.")
vf1 <-
unname(sapply(lapply(fits.nna, function(x)
x[1, ]), function(x)
x[index]))
vf2 <-
unname(sapply(lapply(fits.nna, function(x)
x[2, ]), function(x)
x[index]))
co1 <- rep(NA, length(index))
co2 <- co1
probs <-
sapply(gof, function(x)
ifelse(x, alpha.lev, 1 - alpha.lev))
for (i in 1:length(index)) {
#Type of stats::quantile is set to 8
if (length(index) > 1) {
co1[i] <-
stats::quantile(vf1[i, ], probs[i], type = 8)
co2[i] <-
stats::quantile(vf2[i, ], probs[i], type = 8)
}
if (length(index) == 1) {
co1[i] <-
stats::quantile(vf1, probs, type = 8)
co2[i] <-
stats::quantile(vf2, probs, type = 8)
}
}
co <- rbind(co1, co2)
dimnames(co) <- list(c("Model 1", "Model 2"), toupper(index))
names(gof) <- toupper(index)
rco <-
list(
"cutoff" = co,
"difference" = co[1, ] - co[2, ],
"index" = toupper(index),
"alpha" = alpha.lev,
"gof" = gof,
"replications" = length(fits),
"number of non-converging models" = na,
"share of non-converging models" = round(sh.na, 3)
)
}
return(rco)
}
#' Obtain recommendations based on Mai et al. (2021)
#'
#' This function recommends pre-defined selected fit indices in case the user does not know which fit index should be used for model evaluation. Results may differ based on three settings, the sample size of the data, the research purpose of the investigated model and the focus of the model. For obvious reasons, this function only works for single models and does not accept any other model type.
#' @param fits A list of simulated fit indices obtained from gen_fit. Based on the structure of fits, the number of models is derived.
#' @param purpose The research purpose of the model investigated. Is the underlying model novel (default) or established (= established). This parameter is relevant to find the proper recommended fit indices.
#' @param focus The focus of estimation for the model. Is the focus on CFA (default) or analyzing the structural model of a theoretical model (= structural)? This parameter is relevant to find the proper recommended fit indices.
#' @param override Should the recommendations by Mai et al. (2021) overridden (default: FALSE)?  This may be useful to explore models outside of the scope of the paper. In this case, the recommended fit indices are not determined by the function, and hence need to be provided.
#' In this case, the function requires the argument index.
#' @param index An optional vector of fit indices or measures provided by function fitmeasures in package lavaan. This argument is required when override is TRUE. It is ignored otherwise.
#' @return A list of information regarding the recommended fit indices based on Mai et al. (2021) or when overridden, based on the provided indices.
#' @references Mai, R., Niemand, T., & Kraus, S. (2021). A Tailor-Fit Model Evaluation Strategy for Better Decisions about Structural Equation Models, Technological Forecasting & Social Change (forthcoming).
#' @examples
#'x <-
#'  data.frame(MASS::mvrnorm(
#'    Sigma = bb1992,
#'    mu = rep(0, nrow(bb1992)),
#'    n = 502,
#'    empirical = TRUE
#'  ))
#'#Niemand & Mai (2018, p. 1170)
#'mod <- "
#'F1 =~ Q5 + Q7 + Q8
#'F2 =~ Q2 + Q4
#'F3 =~ Q10 + Q11 + Q12 + Q13 + Q18 + Q19 + Q20 + Q21 + Q22
#'F4 =~ Q1 + Q17
#'F5 =~ Q6 + Q14 + Q15 + Q16
#'"
#'fits.single <- gen_fit(mod1 = mod, x = x, rep = 100, standardized = FALSE)
#'recommend(fits.single)
#'recommend(fits.single, purpose = "established")
#'recommend(fits.single,
#'          override = TRUE,
#'          index = c("CFI", "SRMR"))
#' @export
recommend <-
function(fits,
purpose = "novel",
focus = "cfa",
override = FALSE,
index = NULL) {
if (!is.null(dim(fits$fco[[1]])))
stop(
"Only single model fit indices are supported so far for this function. Please revise or use flex_co."
)
checkmate::assertCharacter(fits$mod1,
fixed = "=~")
checkmate::assertDataFrame(fits$x,
min.rows = 50,
min.cols = 4,
col.names = "unique")
if (purpose != "novel")
purpose <- "established"
checkmate::assert(
checkmate::checkCharacter(purpose,
pattern = "novel"),
checkmate::checkCharacter(purpose,
pattern = "established"),
)
if (focus != "cfa")
focus <- "structure"
checkmate::assert(
checkmate::checkCharacter(focus,
pattern = "cfa"),
checkmate::checkCharacter(focus,
pattern = "structure"),
)
n <- nrow(fits$x)
fm <-
try(lavaan::fitmeasures(lavaan::cfa(
fits$mod1,
data = fits$x,
estimator = "MLM",
auto.fix.first = FALSE,
std.lv = TRUE
)), silent = TRUE)
if (inherits(fm, "try-error"))
stop("Invalid model or data. Please revise.")
if (!override) {
if (purpose == "established" & focus == "cfa" & n <= 200) {
#C1: SRMR flex
index <- "srmr"
ap <- c(.001, .01, .05, .10)
fc <- suppressWarnings(sapply(ap, flex_co, fits = fits, index = index))
co <- fc[1, ]
gof <- fc[4, ]
na <- fc[6, 1]
sh.na <- fc[7, 1]
rf <- fm[index]
}
if (purpose == "established" & focus == "cfa" & n > 200) {
#C2: CFI fix
index <- "cfi"
ap <- NULL
fc <- NULL
na <- NULL
sh.na <- NULL
co <- .95
gof <- index_guess(index)
rf <- fm[index]
}
if (purpose == "established" &
focus == "structure" & n <= 200) {
#C3: SRMR flex
index <- "srmr"
ap <- c(.001, .01, .05, .10)
fc <- suppressWarnings(sapply(ap, flex_co, fits = fits, index = index))
co <- fc[1, ]
gof <- fc[4, ]
na <- fc[6, 1]
sh.na <- fc[7, 1]
rf <- fm[index]
}
if (purpose == "established" &
focus == "structure" & n > 200) {
#C4: SRMR flex
index <- "srmr"
ap <- c(.001, .01, .05, .10)
fc <- suppressWarnings(sapply(ap, flex_co, fits = fits, index = index))
co <- fc[1, ]
gof <- fc[4, ]
na <- fc[6, 1]
sh.na <- fc[7, 1]
rf <- fm[index]
}
if (purpose == "novel" & focus == "cfa" & n <= 200) {
#C5: CFI fix
index <- "cfi"
ap <- NULL
fc <- NULL
na <- NULL
sh.na <- NULL
co <- .95
gof <- index_guess(index)
rf <- fm[index]
}
if (purpose == "novel" & focus == "cfa" & n > 200) {
#C6: SRMR flex
index <- "srmr"
ap <- c(.001, .01, .05, .10)
fc <- suppressWarnings(sapply(ap, flex_co, fits = fits, index = index))
co <- fc[1, ]
gof <- fc[4, ]
na <- fc[6, 1]
sh.na <- fc[7, 1]
rf <- fm[index]
}
if (purpose == "novel" & focus == "structure" & n <= 200) {
#C7: CFI & SRMR fix
index <- c("cfi", "srmr")
ap <- NULL
fc <- NULL
na <- NULL
sh.na <- NULL
co <- c(.95, .09)
gof <- sapply(index, index_guess)
rf <- fm[index]
}
if (purpose == "novel" & focus == "structure" & n > 200) {
#C8: SRMR flex
index <- "srmr"
ap <- c(.001, .01, .05, .10)
fc <- suppressWarnings(sapply(ap, flex_co, fits = fits, index = index))
co <- fc[1, ]
gof <- fc[4, ]
na <- fc[6, 1]
sh.na <- fc[7, 1]
rf <- fm[index]
}
}
if (override) {
if (is.null(index))
stop(
"You chose to override the recommendation patterns. In this case, you need to provide index names. Please revise."
)
index <- tolower(index)
ap <- c(.001, .01, .05, .10)
fc <- suppressWarnings(sapply(ap, flex_co, fits = fits, index = index))
co <- fc[1, ]
gof <- fc[4, ]
na <- fc[6, 1]
sh.na <- fc[7, 1]
rf <- fm[index]
}
if (!is.null(ap)) {
tab <-
data.frame(matrix(
unlist(co),
nrow = length(ap),
ncol = length(index),
byrow = TRUE
))
names(tab) <- toupper(index)
rownames(tab) <- ap
gof <-
data.frame(matrix(
unlist(gof),
nrow = length(ap),
ncol = length(index),
byrow = TRUE
))
names(gof) <- toupper(index)
rownames(gof) <- ap
decs <- gof
for (i in 1:length(index)) {
decs[, i] <- rf[i] - tab[, i]
decs[, i] <-
ifelse(gof[, i] == TRUE, decs[, i], decs[, i] * -1)
decs[, i] <- ifelse(decs[, i] > 0, "confirmed", "rejected")
}
rownames(decs) <- paste0("cutoff ", ap)
rownames(tab) <- paste0("cutoff ", ap)
if (fits$rep < 500)
warning(
"The number of replications is lower than the recommended minimum of 500. Consider with care."
)
res <- list(
"recommended.fit.indices" = toupper(index),
"gof" = unname(sapply(index, index_guess)),
"fit.values" = unname(rf),
"cutoffs" = tab,
"decisions" = decs,
"replications" = fits$rep,
"comment" = ifelse(
override,
"Override mode",
"Recommendations based on flexible cutoffs and Mai et al. (2021)"
)
)
}
if (is.null(ap)) {
decs <- rf - co
decs <- ifelse(gof == "GoF", decs, decs * -1)
decs <- ifelse(decs > 0, "confirmed", "rejected")
res <- list(
"recommended.fit.indices" = toupper(index),
"gof" = unname(sapply(index, index_guess)),
"fit.values" = unname(rf),
"decisions" = decs,
"comment" = "Recommendations based on fixed cutoffs and Mai et al. (2021)"
)
}
return(res)
}
#' Obtain recommendations for discriminant validity testing
#'
#' This function recommends on potential issues for discriminant validity testing, based on  differences between fit values and differences between flexible cutoffs. Two approaches of testing are supported: merging and constraining.
#' @param fits A list of simulated fit indices obtained from gen_fit. Based on the structure of fits, the number of models is derived.
#' @param index A vector of fit indices or measures provided by function fitmeasures in package lavaan. The default is set to CFI.
#' @return A list of information regarding discriminant validity testing.
#' @examples
#'x <-
#'  data.frame(MASS::mvrnorm(
#'    Sigma = bb1992,
#'    mu = rep(0, nrow(bb1992)),
#'    n = 502,
#'    empirical = TRUE
#'  ))
#'#Niemand & Mai (2018, p. 1170)
#'mod <- "
#'F1 =~ Q5 + Q7 + Q8
#'F2 =~ Q2 + Q4
#'F3 =~ Q10 + Q11 + Q12 + Q13 + Q18 + Q19 + Q20 + Q21 + Q22
#'F4 =~ Q1 + Q17
#'F5 =~ Q6 + Q14 + Q15 + Q16
#'"
#' #Two models for discriminant validity testing, this resembles constraining with a cutoff of .9
#'fits.dv.con <- gen_fit(
#'  mod1 = mod,
#'  x = x,
#'  rep = 100,
#'  dv = TRUE,
#'  dv.factors = c("F4", "F5"),
#'  dv.cutoff = .9
#')
#'recommend.dv(fits.dv.con)
#' #Two models for discriminant validity testing, this resembles merging.
#'fits.dv.merge <- gen_fit(
#'  mod1 = mod,
#'  x = x,
#'  rep = 100,
#'  dv = TRUE,
#'  dv.factors = c("F4", "F5"),
#'  merge.mod = TRUE
#')
#'recommend.dv(fits.dv.merge)
#' @export
recommend.dv <-
function(fits,
index = "CFI") {
if (is.null(dim(fits$fco[[1]])))
stop(
"Only dual model fit indices are supported so far for this function. Please revise or use flex_co."
)
checkmate::assertCharacter(fits$mod1,
fixed = "=~")
checkmate::assertDataFrame(fits$x,
min.rows = 50,
min.cols = 4,
col.names = "unique")
checkmate::assertVector(fits$dv.factors, len = 2, null.ok = TRUE)
checkmate::assertLogical(fits$merge.mod, null.ok = TRUE)
checkmate::assertVector(fits$dv.cutoff, len = 1, null.ok = TRUE)
mode <- ifelse(fits$merge.mod, "merging", "constraining")
fm <-
try(lavaan::fitmeasures(lavaan::cfa(
fits$mod1,
data = fits$x,
estimator = "MLM",
auto.fix.first = FALSE,
std.lv = TRUE
)), silent = TRUE)
if (inherits(fm, "try-error"))
stop("Invalid model or data. Please revise.")
# if (!tolower(index) %in% names(fm))
#   stop(
#     "The index names provided do not match the names of the indices provided by lavaan. Please revise."
#   )
if (mode == "constraining") {
mod2 <-
constr_mod(fits$mod1, dv.factors = fits$dv.factors, dv.cutoff = fits$dv.cutoff)
fm2 <-
try(lavaan::fitmeasures(lavaan::cfa(
fits$mod2,
data = fits$x,
estimator = "MLM",
auto.fix.first = FALSE,
std.lv = TRUE
)), silent = TRUE)
if (inherits(fm2, "try-error"))
stop("Invalid model or data. Please revise.")
}
if (mode == "merging") {
pop.mod <- pop_mod(
mod = fits$mod1,
x = fits$x,
type = fits$type,
standardized = fits$standardized
)$pop.mod
pt2 <-
try(merge_factors(lavaan::cfa(pop.mod, fits$x, warn = FALSE), merged.factors = fits$dv.factors),
silent = TRUE)
if (inherits(pt2, "try-error"))
stop("Merging two-factors not successful. Please check.")
mod2 <- get_free(pt2, fits$dv.factors, mode)
fm2 <-
try(lavaan::fitmeasures(lavaan::cfa(
mod2,
data = fits$x,
estimator = "MLM",
auto.fix.first = FALSE,
std.lv = TRUE
)), silent = TRUE)
if (inherits(fm2, "try-error"))
stop("Invalid model or data. Please revise.")
}
index <- tolower(index)
ap <- c(.001, .01, .05, .10)
#gof <- ifelse(sapply(index, index_guess) == "GoF", TRUE, FALSE)
fc <- suppressWarnings(sapply(ap, flex_co, fits = fits, index = index))
#fc <- suppressWarnings(sapply(ap, flex_co, fits = fits, index = index, gof = gof))
#fc2 <- suppressWarnings(sapply(ap, flex_co, fits = fits, index = index, gof = !gof))
#for (i in 1:length(ap)) {
#  fc[1,][[i]][2, ] <- fc2[1,][[i]][2, ]
#}
co <- lapply(fc[1, ], as.data.frame)
gof <- fc[5, ]
na <- fc[7, 1]
sh.na <- fc[8, 1]
rf1 <- fm[tolower(index)]
rf2 <- fm2[tolower(index)]
tab <- data.table::rbindlist(co)
mn <- ifelse(mode == "constraining", "constrained", "merged")
tab <- as.data.frame(cbind(tab, expand.grid(c("original", mn), ap)))
colnames(tab) <- c(toupper(index), "model", "alpha")
fi <- data.frame(rbind(rf1, rf2))
rownames(fi) <- NULL
alpha <- NULL
fi$model <- c("original", mn)
colnames(fi)[1:length(index)] <- c(toupper(index))
diff <- data.frame(matrix(NA, nrow = length(ap), ncol = length(index)))
for (i in 1:length(ap)) {
ss <- subset(tab, alpha == ap[i])[,1:length(index)]
if(length(index) == 1) {
diff[i, ] <- ss[1] - ss[2]
}
if(length(index) > 1) {
diff[i,] <- ss[1,] - ss[2,]
}
}
names(diff) <- toupper(index)
diff <- t(rbind(diff, fi[1,1:length(index)] - fi[2,1:length(index)]))
colnames(diff) <- c(paste0("cutoff ", ap), "fit")
decide.dv <- function(tab, fi, diff, index) {
model <- NULL
ctab <- subset(tab, model == "original")[,toupper(index)]
cfi <- subset(fi, model == "original")[,toupper(index)]
whr <- which(sapply(colnames(ctab), index_guess) == "BoF")
if (!is.null(nrow(ctab))) {
decs <- data.frame(matrix(NA, nrow = nrow(ctab), ncol = ncol(ctab)))
for (i in 1:nrow(decs)) {
#For GoF, that is the version from the flc paper
decs[i,] <- ifelse(cfi <= ctab[i,], 1, -1)
}
#For BoF: reverse
decs[,whr] <- decs[,whr] * -1
decs[decs == 1] <- "confirmed"
decs[decs == -1] <- "rejected"
names(decs) <- colnames(ctab)
rownames(decs) <- colnames(diff)[1:nrow(decs)]
}
if (is.null(nrow(ctab))) {
#For GoF, that is the version from the flc paper
decs <- ifelse(cfi <= ctab, 1, -1)
#For BoF: reverse
decs[whr] <- decs[whr] * -1
decs[decs == 1] <- "confirmed"
decs[decs == -1] <- "rejected"
names(decs) <- names(ctab)
}
return(decs)
}
# decide.dv <- function(diff) {
#   whc <- which(colnames(diff) == "fit")
#   whr <- which(sapply(rownames(diff), index_guess) == "BoF")
#   decs <- data.frame(matrix(NA, nrow = nrow(diff), ncol = ncol(diff) - 1))
#   for (i in 1:ncol(decs)) {
#     #For GoF, that is the version from the flc paper
#     decs[,i] <- ifelse(diff[,whc] >= diff[,i], 1, -1)
#   }
#   #For BoF: reverse
#   decs[whr,] <- decs[whr,] * -1
#   decs[decs == 1] <- "confirmed"
#   decs[decs == -1] <- "rejected"
#   names(decs) <- colnames(diff)[-whc]
#   rownames(decs) <- rownames(diff)
#   return(decs)
# }
#decs <- decide.dv(diff)
decs <- decide.dv(tab, fi, diff, index)
#decs <- data.frame(t(decs))
diff <- data.frame(t(diff))
if (fits$rep < 500)
warning(
"The number of replications is lower than the recommended minimum of 500. Consider with care."
)
res <- list(
"cutoffs" = tab,
"fit.values" = fi,
"differences" = diff,
"decisions" = decs,
"replications" = fits$rep,
"comment" = paste0(
"Approach for discriminant validity testing: ",
mode,
". Discriminant validity is confirmed if the fit value from the constrained/merged model is smaller (GoF) / larger (BoF) than the respective cutoff of original model."
)
)
return(res)
}
?devtools::check
