
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "FCO"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "FCO-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('FCO')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("bb1992")
> ### * bb1992
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: bb1992
> ### Title: Dataset from Babakus & Boller (1992)
> ### Aliases: bb1992
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(bb1992)
> head(bb1992, 3)
          Q1         Q2         Q3        Q4         Q5         Q6         Q7
1 -1.0206565  0.2276041 -1.2568654 0.8136901 -1.6019692  0.7552052 -0.4227379
2  1.5938691 -0.0276403 -1.2359269 0.4527496  0.4198624  1.2915004  0.3614339
3  0.6432085  0.5146161  0.9700383 0.5768854  0.1788848 -0.2423614  0.7111541
          Q8          Q9        Q10        Q11        Q12       Q13         Q14
1 -1.2791570  0.13263442 -0.4502009 -0.3691879 -0.5386581 -1.238408  0.02816952
2  0.4577506 -0.05877489  0.6064040  0.9672691  1.1028063  1.784519 -0.47735634
3 -0.5452735 -0.54137900 -0.8755678  0.3516510 -1.9334731 -0.498252 -0.33502753
          Q15        Q16        Q17        Q18          Q19        Q20
1 -0.36047328  0.3736429 -0.3124173  0.3765030 -0.956071795 1.50488335
2  0.17534870  0.2421734  1.7328168  0.3081753  0.004130691 0.62142902
3 -0.07986953 -1.4054425 -0.7272241 -0.7679232  0.009754038 0.07108398
         Q21        Q22
1 -0.2591684 -0.4093789
2  0.9135299  1.1154500
3 -0.6949648  1.7242517
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("bb1992", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("flex_co")
> ### * flex_co
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: flex_co
> ### Title: Obtain flexible cutoffs for one or two models
> ### Aliases: flex_co
> 
> ### ** Examples
> 
> #Note: Demonstration only! Please use higher numbers of replications for your applications (>= 500).
> #A single model to obtain fit indices for
> mod <- "
+ F1 =~ Q5 + Q7 + Q8
+ F2 =~ Q2 + Q4
+ F3 =~ Q10 + Q11 + Q12 + Q13 + Q18 + Q19 + Q20 + Q21 + Q22
+ F4 =~ Q1 + Q17
+ F5 =~ Q6 + Q14 + Q15 + Q16
+ "
> fits.single <- gen_fit(mod1 = mod, x = bb1992, rep = 10, standardized = FALSE)
Warning in pop_mod(mod = mod1, x = x, type = type, standardized = standardized) :
  All loadings are < 1. Consider revision of standardized.
> flex_co(fits = fits.single, index = c("CFI", "SRMR"))
Warning in flex_co(fits = fits.single, index = c("CFI", "SRMR")) :
  The number of replications is lower than the recommended minimum of 500. Consider with care.
$cutoff
      CFI      SRMR 
0.9691953 0.0356855 

$index
[1] "CFI"  "SRMR"

$alpha
[1] 0.05

$gof
  CFI  SRMR 
 TRUE FALSE 

$replications
[1] 10

$`number of non-converging models`
[1] 0

$`share of non-converging models`
[1] 0

> #Two models, an unconstrained and a constrained model to compare fit indices
> mod.con <- "
+ F1 =~ Q5 + Q7 + Q8
+ F2 =~ Q2 + Q4
+ F3 =~ Q10 + Q11 + Q12 + Q13 + Q18 + Q19 + Q20 + Q21 + Q22
+ F4 =~ Q1 + Q17
+ F5 =~ Q6 + Q14 + Q15 + Q16
+ F1 ~~ 0 * F2
+ "
> fits.con <- gen_fit(
+  mod1 = mod,
+  mod2 = mod.con,
+  x = bb1992,
+  rep = 10
+ )
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
> flex_co(fits = fits.con,
+        index = c("CFI", "SRMR"),
+        alpha.lev = .05)
Warning in flex_co(fits = fits.con, index = c("CFI", "SRMR"), alpha.lev = 0.05) :
  The number of replications is lower than the recommended minimum of 500. Consider with care.
$cutoff
              CFI       SRMR
Model 1 0.9685045 0.03501007
Model 2 0.9563901 0.05653160

$difference
        CFI        SRMR 
 0.01211441 -0.02152153 

$index
[1] "CFI"  "SRMR"

$alpha
[1] 0.05

$gof
  CFI  SRMR 
 TRUE FALSE 

$replications
[1] 10

$`number of non-converging models`
[1] 0

$`share of non-converging models`
[1] 0

> 
> #Two models for discriminant validity testing, this resembles constraining with a cutoff of .9
> fits.dv.con <- gen_fit(
+  mod1 = mod,
+  x = bb1992,
+  rep = 10,
+  dv = TRUE,
+  dv.factors = c("F4", "F5"),
+  dv.cutoff = .9
+ )
Constraining is selected as the discriminant validity testing option given the provided arguments.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
> flex_co(fits = fits.dv.con,
+ index = "CFI",
+ alpha.lev = .05)
Warning in flex_co(fits = fits.dv.con, index = "CFI", alpha.lev = 0.05) :
  The number of replications is lower than the recommended minimum of 500. Consider with care.
$cutoff
              CFI
Model 1 0.9685045
Model 2 0.9678501

$difference
[1] 0.0006543714

$index
[1] "CFI"

$alpha
[1] 0.05

$gof
 CFI 
TRUE 

$replications
[1] 10

$`number of non-converging models`
[1] 0

$`share of non-converging models`
[1] 0

> mod.dv.con <- "
+ F1 =~ Q5 + Q7 + Q8
+ F2 =~ Q2 + Q4
+ F3 =~ Q10 + Q11 + Q12 + Q13 + Q18 + Q19 + Q20 + Q21 + Q22
+ F4 =~ Q1 + Q17
+ F5 =~ Q6 + Q14 + Q15 + Q16
+ F4 ~~ .9 * F5
+ "
> lavaan::fitmeasures(
+  lavaan::cfa(
+    model = mod.dv.con,
+    data = bb1992,
+    auto.fix.first = FALSE,
+    std.lv = TRUE
+  ),
+  fit.measures = "cfi"
+ )
  cfi 
0.959 
> #Two models for discriminant validity testing, this resembles merging.
> fits.dv.merge <- gen_fit(
+  mod1 = mod,
+  x = bb1992,
+  rep = 10,
+  dv = TRUE,
+  dv.factors = c("F4", "F5"),
+  merge.mod = TRUE)
Merging is selected as the discriminant validity testing option given the provided arguments.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
> 
> flex_co(fits = fits.dv.merge,
+ index = "CFI",
+ alpha.lev = .05)
Warning in flex_co(fits = fits.dv.merge, index = "CFI", alpha.lev = 0.05) :
  The number of replications is lower than the recommended minimum of 500. Consider with care.
$cutoff
              CFI
Model 1 0.9685045
Model 2 0.9265251

$difference
[1] 0.04197938

$index
[1] "CFI"

$alpha
[1] 0.05

$gof
 CFI 
TRUE 

$replications
[1] 10

$`number of non-converging models`
[1] 0

$`share of non-converging models`
[1] 0

> mod.dv.merge <- "
+ F1 =~ Q5 + Q7 + Q8
+ F2 =~ Q2 + Q4
+ F3 =~ Q10 + Q11 + Q12 + Q13 + Q18 + Q19 + Q20 + Q21 + Q22
+ F4 =~ Q1 + Q17 + Q6 + Q14 + Q15 + Q16
+ "
> lavaan::fitmeasures(
+  lavaan::cfa(
+    model = mod.dv.merge,
+    data = bb1992
+  ),
+  fit.measures = "cfi"
+ )
  cfi 
0.952 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("flex_co", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("gen_fit")
> ### * gen_fit
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: gen_fit
> ### Title: Obtain fit statistics from one or two models
> ### Aliases: gen_fit
> 
> ### ** Examples
> 
> #Note: Demonstration only! Please use higher numbers of replications for your applications (>= 500).
> #A single model to obtain fit indices for
> mod <- "
+ F1 =~ Q5 + Q7 + Q8
+ F2 =~ Q2 + Q4
+ F3 =~ Q10 + Q11 + Q12 + Q13 + Q18 + Q19 + Q20 + Q21 + Q22
+ F4 =~ Q1 + Q17
+ F5 =~ Q6 + Q14 + Q15 + Q16
+ "
> fits.single <- gen_fit(mod1 = mod, x = bb1992, rep = 10, standardized = FALSE)
Warning in pop_mod(mod = mod1, x = x, type = type, standardized = standardized) :
  All loadings are < 1. Consider revision of standardized.
> 
> #Two models, an unconstrained and a constrained model to compare fit indices
> mod.con <- "
+ F1 =~ Q5 + Q7 + Q8
+ F2 =~ Q2 + Q4
+ F3 =~ Q10 + Q11 + Q12 + Q13 + Q18 + Q19 + Q20 + Q21 + Q22
+ F4 =~ Q1 + Q17
+ F5 =~ Q6 + Q14 + Q15 + Q16
+ F1 ~~ 0 * F2
+ "
> fits.con <- gen_fit(
+  mod1 = mod,
+  mod2 = mod.con,
+  x = bb1992,
+  rep = 10
+ )
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
> #Two models for discriminant validity testing, this resembles constraining with a cutoff of .9
> fits.dv.con <- gen_fit(
+  mod1 = mod,
+  x = bb1992,
+  rep = 10,
+  dv = TRUE,
+  dv.factors = c("F4", "F5"),
+  dv.cutoff = .9
+ )
Constraining is selected as the discriminant validity testing option given the provided arguments.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
> 
> #Two models for discriminant validity testing, this resembles merging.
> fits.dv.merge <- gen_fit(
+  mod1 = mod,
+  x = bb1992,
+  rep = 10,
+  dv = TRUE,
+  dv.factors = c("F4", "F5"),
+  merge.mod = TRUE
+ )
Merging is selected as the discriminant validity testing option given the provided arguments.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("gen_fit", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("index_guess")
> ### * index_guess
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: index_guess
> ### Title: Helper function that guesses GoF or BoF from a given index name
> ### Aliases: index_guess
> 
> ### ** Examples
> 
> index_guess("cfi")
[1] "GoF"
> index_guess("tli")
[1] "GoF"
> index_guess("rmsea")
[1] "BoF"
> index_guess("srmr")
[1] "BoF"
> index_guess("cfi")
[1] "GoF"
> index_guess("tli")
[1] "GoF"
> index_guess("rmsea")
[1] "BoF"
> index_guess("srmr")
[1] "BoF"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("index_guess", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pop_mod")
> ### * pop_mod
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pop_mod
> ### Title: Helper function to obtain population model for simulation based
> ###   on data and model
> ### Aliases: pop_mod
> 
> ### ** Examples
> 
> mod <- "
+ F1 =~ Q5 + Q7 + Q8
+ F2 =~ Q2 + Q4
+ F3 =~ Q10 + Q11 + Q12 + Q13 + Q18 + Q19 + Q20 + Q21 + Q22
+ F4 =~ Q1 + Q17
+ F5 =~ Q6 + Q14 + Q15 + Q16
+ "
> pop_mod(mod, x = bb1992, type = "NM")$pop.mod
[1] "F1=~0.7*Q5+0.7*Q7+0.7*Q8 \nF2=~0.7*Q2+0.7*Q4 \nF3=~0.7*Q10+0.7*Q11+0.7*Q12+0.7*Q13+0.7*Q18+0.7*Q19+0.7*Q20+0.7*Q21+0.7*Q22 \nF4=~0.7*Q1+0.7*Q17 \nF5=~0.7*Q6+0.7*Q14+0.7*Q15+0.7*Q16 \nF1~~1*F1 \nF2~~0.3*F1 \nF3~~0.3*F1 \nF4~~0.3*F1 \nF5~~0.3*F1 \nF2~~1*F2 \nF3~~0.3*F2 \nF4~~0.3*F2 \nF5~~0.3*F2 \nF3~~1*F3 \nF4~~0.3*F3 \nF5~~0.3*F3 \nF4~~1*F4 \nF5~~0.3*F4 \nF5~~1*F5 \n \n"
> pop_mod(mod, x = bb1992, type = "HB")$pop.mod
[1] "F1=~0.7*Q5+0.75*Q7+0.8*Q8 \nF2=~0.75*Q2+0.75*Q4 \nF3=~0.7*Q10+0.7*Q11+0.7*Q12+0.7*Q13+0.75*Q18+0.8*Q19+0.8*Q20+0.8*Q21+0.8*Q22 \nF4=~0.75*Q1+0.75*Q17 \nF5=~0.7*Q6+0.75*Q14+0.75*Q15+0.8*Q16 \nF1~~1*F1 \nF2~~0.5*F1 \nF3~~0.4*F1 \nF4~~0.3*F1 \nF5~~0.5*F1 \nF2~~1*F2 \nF3~~0.4*F2 \nF4~~0.5*F2 \nF5~~0.4*F2 \nF3~~1*F3 \nF4~~0.3*F3 \nF5~~0.5*F3 \nF4~~1*F4 \nF5~~0.4*F4 \nF5~~1*F5 \n \n"
> pop_mod(mod, x = bb1992, type = "EM")$pop.mod
[1] "F1=~0.807*Q5+0.637*Q7+0.876*Q8 \nF2=~0.747*Q2+0.842*Q4 \nF3=~0.519*Q10+0.568*Q11+0.597*Q12+0.697*Q13+0.603*Q18+0.557*Q19+0.534*Q20+0.578*Q21+0.552*Q22 \nF4=~0.659*Q1+0.772*Q17 \nF5=~0.727*Q6+0.719*Q14+0.826*Q15+0.752*Q16 \nF1~~1*F1 \nF2~~0.36*F1 \nF3~~0.71*F1 \nF4~~0.641*F1 \nF5~~0.807*F1 \nF2~~1*F2 \nF3~~0.349*F2 \nF4~~0.486*F2 \nF5~~0.492*F2 \nF3~~1*F3 \nF4~~0.625*F3 \nF5~~0.8*F3 \nF4~~1*F4 \nF5~~0.831*F4 \nF5~~1*F5 \n \n"
> pop_mod(mod, x = bb1992, type = "NM", afl = .9)$pop.mod
[1] "F1=~0.9*Q5+0.9*Q7+0.9*Q8 \nF2=~0.9*Q2+0.9*Q4 \nF3=~0.9*Q10+0.9*Q11+0.9*Q12+0.9*Q13+0.9*Q18+0.9*Q19+0.9*Q20+0.9*Q21+0.9*Q22 \nF4=~0.9*Q1+0.9*Q17 \nF5=~0.9*Q6+0.9*Q14+0.9*Q15+0.9*Q16 \nF1~~1*F1 \nF2~~0.3*F1 \nF3~~0.3*F1 \nF4~~0.3*F1 \nF5~~0.3*F1 \nF2~~1*F2 \nF3~~0.3*F2 \nF4~~0.3*F2 \nF5~~0.3*F2 \nF3~~1*F3 \nF4~~0.3*F3 \nF5~~0.3*F3 \nF4~~1*F4 \nF5~~0.3*F4 \nF5~~1*F5 \n \n"
> pop_mod(mod, x = bb1992, type = "NM", aco = .5)$pop.mod
[1] "F1=~0.7*Q5+0.7*Q7+0.7*Q8 \nF2=~0.7*Q2+0.7*Q4 \nF3=~0.7*Q10+0.7*Q11+0.7*Q12+0.7*Q13+0.7*Q18+0.7*Q19+0.7*Q20+0.7*Q21+0.7*Q22 \nF4=~0.7*Q1+0.7*Q17 \nF5=~0.7*Q6+0.7*Q14+0.7*Q15+0.7*Q16 \nF1~~1*F1 \nF2~~0.5*F1 \nF3~~0.5*F1 \nF4~~0.5*F1 \nF5~~0.5*F1 \nF2~~1*F2 \nF3~~0.5*F2 \nF4~~0.5*F2 \nF5~~0.5*F2 \nF3~~1*F3 \nF4~~0.5*F3 \nF5~~0.5*F3 \nF4~~1*F4 \nF5~~0.5*F4 \nF5~~1*F5 \n \n"
> pop_mod(mod, x = bb1992, type = "EM", standardized = FALSE)$pop.mod
Warning in pop_mod(mod, x = bb1992, type = "EM", standardized = FALSE) :
  All loadings are < 1. Consider revision of standardized.
[1] "F1=~0.807*Q5+0.637*Q7+0.876*Q8 \nF2=~0.747*Q2+0.842*Q4 \nF3=~0.519*Q10+0.568*Q11+0.597*Q12+0.697*Q13+0.603*Q18+0.557*Q19+0.534*Q20+0.578*Q21+0.552*Q22 \nF4=~0.659*Q1+0.772*Q17 \nF5=~0.727*Q6+0.719*Q14+0.826*Q15+0.752*Q16 \nF1~~1*F1 \nF2~~0.36*F1 \nF3~~0.71*F1 \nF4~~0.641*F1 \nF5~~0.807*F1 \nF2~~1*F2 \nF3~~0.349*F2 \nF4~~0.486*F2 \nF5~~0.492*F2 \nF3~~1*F3 \nF4~~0.625*F3 \nF5~~0.8*F3 \nF4~~1*F4 \nF5~~0.831*F4 \nF5~~1*F5 \n"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pop_mod", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("recommend")
> ### * recommend
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: recommend
> ### Title: Obtain recommendations based on Mai et al. (2021)
> ### Aliases: recommend
> 
> ### ** Examples
> 
> #Note: Demonstration only! Please use higher numbers of replications for your applications (>= 500).
> mod <- "
+ F1 =~ Q5 + Q7 + Q8
+ F2 =~ Q2 + Q4
+ F3 =~ Q10 + Q11 + Q12 + Q13 + Q18 + Q19 + Q20 + Q21 + Q22
+ F4 =~ Q1 + Q17
+ F5 =~ Q6 + Q14 + Q15 + Q16
+ "
> fits.single <- gen_fit(mod1 = mod, x = bb1992, rep = 10, standardized = FALSE)
Warning in pop_mod(mod = mod1, x = x, type = type, standardized = standardized) :
  All loadings are < 1. Consider revision of standardized.
> recommend(fits.single)
Warning in recommend(fits.single) :
  The number of replications is lower than the recommended minimum of 500. Consider with care.
$recommended
     type fit.values
SRMR  BoF      0.038

$cutoffs
              SRMR
cutoff 0.001 0.036
cutoff 0.01  0.036
cutoff 0.05  0.036
cutoff 0.1   0.035

$decisions
                 SRMR
cutoff 0.001 rejected
cutoff 0.01  rejected
cutoff 0.05  rejected
cutoff 0.1   rejected

$replications
[1] 10

$comment
[1] "Recommendations based on flexible cutoffs and Mai et al. (2021)"

> recommend(fits.single, purpose = "established")
$recommended
    type fit.values
CFI  GoF       0.96

$decisions
[1] "confirmed"

$comment
[1] "Recommendations based on fixed cutoffs and Mai et al. (2021)"

> recommend(fits.single,
+          override = TRUE,
+          index = c("CFI", "SRMR"))
Warning in recommend(fits.single, override = TRUE, index = c("CFI", "SRMR")) :
  The number of replications is lower than the recommended minimum of 500. Consider with care.
$recommended
     type fit.values
CFI   GoF      0.960
SRMR  BoF      0.038

$cutoffs
               CFI  SRMR
cutoff 0.001 0.969 0.036
cutoff 0.01  0.969 0.036
cutoff 0.05  0.969 0.036
cutoff 0.1   0.970 0.035

$decisions
                  CFI     SRMR
cutoff 0.001 rejected rejected
cutoff 0.01  rejected rejected
cutoff 0.05  rejected rejected
cutoff 0.1   rejected rejected

$replications
[1] 10

$comment
[1] "Override mode"

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("recommend", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("recommend_dv")
> ### * recommend_dv
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: recommend_dv
> ### Title: Obtain recommendations for discriminant validity testing
> ### Aliases: recommend_dv
> 
> ### ** Examples
> 
> #Note: Demonstration only! Please use higher numbers of replications for your applications (>= 500).
> mod <- "
+ F1 =~ Q5 + Q7 + Q8
+ F2 =~ Q2 + Q4
+ F3 =~ Q10 + Q11 + Q12 + Q13 + Q18 + Q19 + Q20 + Q21 + Q22
+ F4 =~ Q1 + Q17
+ F5 =~ Q6 + Q14 + Q15 + Q16
+ "
> #Two models for discriminant validity testing, this resembles constraining with a cutoff of .9
> fits.dv.con <- gen_fit(
+  mod1 = mod,
+  x = bb1992,
+  rep = 10,
+  dv = TRUE,
+  dv.factors = c("F4", "F5"),
+  dv.cutoff = .9
+ )
Constraining is selected as the discriminant validity testing option given the provided arguments.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
> recommend_dv(fits.dv.con)
Warning in recommend_dv(fits.dv.con) :
  The number of replications is lower than the recommended minimum of 500. Consider with care.
$cutoffs
    CFI       model alpha
1 0.969    original 0.001
2 0.968 constrained 0.001
3 0.969    original 0.010
4 0.968 constrained 0.010
5 0.969    original 0.050
6 0.968 constrained 0.050
7 0.970    original 0.100
8 0.969 constrained 0.100

$fit.values
    CFI       model
1 0.960    original
2 0.959 constrained

$differences
               CFI
cutoff 0.001 0.001
cutoff 0.01  0.001
cutoff 0.05  0.001
cutoff 0.1   0.001
fit          0.001

$decisions
                   CFI
cutoff 0.001 confirmed
cutoff 0.01  confirmed
cutoff 0.05  confirmed
cutoff 0.1   confirmed

$replications
[1] 10

$comment
[1] "Approach for discriminant validity testing: constraining. Discriminant validity is confirmed if the fit value from the constrained/merged model is smaller (GoF) / larger (BoF) than the respective cutoff of original model."

> #Two models for discriminant validity testing, this resembles merging.
> fits.dv.merge <- gen_fit(
+  mod1 = mod,
+  x = bb1992,
+  rep = 10,
+  dv = TRUE,
+  dv.factors = c("F4", "F5"),
+  merge.mod = TRUE
+ )
Merging is selected as the discriminant validity testing option given the provided arguments.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
Warning in lav_object_post_check(object) :
  lavaan WARNING: covariance matrix of latent variables
                is not positive definite;
                use lavInspect(fit, "cov.lv") to investigate.
> recommend_dv(fits.dv.merge)
Warning in recommend_dv(fits.dv.merge) :
  The number of replications is lower than the recommended minimum of 500. Consider with care.
$cutoffs
    CFI    model alpha
1 0.969 original 0.001
2 0.927   merged 0.001
3 0.969 original 0.010
4 0.927   merged 0.010
5 0.969 original 0.050
6 0.927   merged 0.050
7 0.970 original 0.100
8 0.929   merged 0.100

$fit.values
    CFI    model
1 0.960 original
2 0.952   merged

$differences
               CFI
cutoff 0.001 0.042
cutoff 0.01  0.042
cutoff 0.05  0.042
cutoff 0.1   0.041
fit          0.008

$decisions
                   CFI
cutoff 0.001 confirmed
cutoff 0.01  confirmed
cutoff 0.05  confirmed
cutoff 0.1   confirmed

$replications
[1] 10

$comment
[1] "Approach for discriminant validity testing: merging. Discriminant validity is confirmed if the fit value from the constrained/merged model is smaller (GoF) / larger (BoF) than the respective cutoff of original model."

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("recommend_dv", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.74 0.208 11.453 17.811 1.032 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
